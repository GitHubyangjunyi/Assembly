         ;代码清单7-1
         ;文件名：c07_mbr.asm
         ;文件说明：硬盘主引导扇区代码
         ;创建日期：2011-4-13 18:02
         
         jmp near start
	
 message db '1+2+3+...+100='    ;编译阶段,编译器将其拆开形成一个个单独的字节
        
 start:
         mov ax,0x7c0           ;设置数据段的段基地址 
         mov ds,ax

         mov ax,0xb800          ;设置附加段基址到显示缓冲区
         mov es,ax

         ;以下显示字符串 
         mov si,message          
         mov di,0
         mov cx,start-message   ;下面的loop指令依赖于cx寄存器中存储的循环次数,处理器在执行loop指令指令时候会顺序做两件事:1.将CX寄存器的内容减一;2.如果CX不为0,转移到指定的位置处执行,否则顺序执行后面的指令
     @g:
         mov al,[si]
         mov [es:di],al
         inc di
         mov byte [es:di],0x07
         inc di
         inc si
         loop @g                ;loop放在后面,若cx初始化为2,则循环体执行一次时,cx还是2,然后遇到loop,cx减1,这时候cx=1,接着循环一次,再遇到loop,cx减1,cx=0,不再执行循环,循环一共执行2次

         ;以下计算1到100的和 
         xor ax,ax              ;清零ax
         mov cx,1
     @f:
         add ax,cx
         inc cx
         cmp cx,100
         jle @f                 ;小于等于100则跳转

         ;以下计算累加和的每个数位 
         xor cx,cx              ;设置堆栈段的段基地址
         mov ss,cx              ;栈段段地址为0x0000
         mov sp,cx              ;栈指针内容为0x0000

         mov bx,10              ;除数10
         xor cx,cx              ;由于每次得到的数位是压人栈的,将来还要反序弹出,清零cx用于累计多少个数位
     @d:
         inc cx
         xor dx,dx              ;清零dx,形成32位的dx:ax被除数
         div bx
         or dl,0x30             ;由于0x30=00110000,dl与0x30使用或运算相当于"加上"0x30,这是用或指令做加法的特例
         push dx                ;将寄存器dx中的内容压入栈中,处理器在执行push指令时,首先将栈指针寄存器sp的内容减去操作数的字长(以字节为单位),然后把要压入栈的数据存放到逻辑地址ss:sp所指向的内存位置(和其他段读写一样,将栈段寄存器ss左移4位,加上sp偏移地址),push不影响任何标志位
         cmp ax,0               ;第一次压栈时,sp-2=0x0000-0x0002=0xFFFE,于是被压入栈的数据在内存0x0000:0xFFFE,以后每次压栈,sp都要依次减去2,push指令的操作数是字,Intel处理器使用地段字节序,低字节在低地址
         jne @d                 ;商不等于0(不相等)跳转

         ;以下显示各个数位 
     @a:
         pop dx                 ;将逻辑地址ss:sp处的一个字弹出到dx中,然后将sp的内容加上操作数的字长(2),pop指令执行时,处理器将栈段寄存器ss左移4位,加上sp偏移地址形成20位物理地址,pop指令不影响任何标志位
         mov [es:di],dl
         inc di
         mov byte [es:di],0x07
         inc di
         loop @a                ;当处理器最后一次执行出栈操作后,sp的内容恢复到最开始设置时的状态
       
         jmp near $ 
       

times 510-($-$$) db 0
                 db 0x55,0xaa
;程序执行时的栈分布
;          ________________
;0000:FFFF|     高字节      |
;0000:FFFE|     低字节      |<----第一次压栈时,sp=0xFFFE
;          ----------------
;         |                |堆栈的推进方向
;         |                |    |
;         |                |    |
;         |                |    |
;         |                |    |
;         |                |    |
;         |                |    |
;         |                |    |
;         |                |   \|/
;         ~                ~
;         ~                ~    栈空间共有0xFFFF-0x7EOO+1=0x8200字节
;         |                |
;         |                |
;         |                |
;         |                |
;         |                |
;         |                |   /|\
;         |                |    |
;         |                |    |
;0000:7E00 ----------------     |
;         |                |    |
;         |      MBR       |    |
;         |     512Byte    |    |
;         |                |    |
;         |                |程序的执行方向
;0000:7C00 ----------------
;         |                |
;         |                |
;         |                |
;0000:0000 ----------------
;push指令的操作数可以是16位寄存器或16位内存单元
;push指令执行后,压人栈中的仅仅是该寄存器或内存单元里的数值,与该寄存器或内存单元不再相关
;下面的指令是合法且正确的
;push cs
;pop ds
;意思是将代码段寄存器的内容压栈,并弹出到数据段寄存器ds,如此一来代码段和数据段将同属一个段
;相当于
;mov ax,cs
;mov ds,ax
;栈的本质也是内存段而已,之所以要用push和pop指令进行操作,是因为将它看成栈,为了方便程序开发临时保存数据到栈中
;在编写程序是应充分考虑所需要的占空间,防止破坏有用的数据,特别是栈段和其他段同属一个段时,此程序栈段和代码段相同,段地址都是0x0000,段长度都是64KB
;为避免错误,可以将栈定义到一个单独的64KB段,无论sp怎么变化,压栈和出栈始终在该段内进行,不会破坏其他段
;即使push指令位于一个无限循环中,栈指针寄存器sp永远只在0x0000~0xFFFF之间来回滚动,不影响其他段